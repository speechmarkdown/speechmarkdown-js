#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const https = require('https');
const { URL, URLSearchParams } = require('url');
const aws4 = require('aws4');
const { HttpsProxyAgent } = require('https-proxy-agent');

const proxyAgent = (() => {
  const proxyUrl =
    process.env.HTTPS_PROXY ||
    process.env.https_proxy ||
    process.env.HTTP_PROXY ||
    process.env.http_proxy ||
    null;

  if (!proxyUrl) {
    return null;
  }

  try {
    return new HttpsProxyAgent(proxyUrl);
  } catch (error) {
    console.warn(`[proxy] failed to configure agent for ${proxyUrl}: ${error.message}`);
    return null;
  }
})();

const rootDir = path.resolve(__dirname, '..');
const formatterDataDir = path.join(rootDir, 'src', 'formatters', 'data');

function ensureFormatterDataDir() {
  fs.mkdirSync(formatterDataDir, { recursive: true });
}

function formatObjectLiteral(value, indent) {
  const json = JSON.stringify(value ?? null, null, 2);
  const lines = json.split('\n');

  if (lines.length === 1) {
    return lines[0];
  }

  const indentText = indent || '    ';
  return lines
    .map((line, index) => (index === 0 ? line : `${indentText}${line}`))
    .join('\n');
}

function writeFormatterVoiceModule(fileName, exports) {
  if (!exports || exports.length === 0) {
    return;
  }

  ensureFormatterDataDir();
  const filePath = path.join(formatterDataDir, fileName);
  const lines = [
    '// THIS FILE IS AUTO-GENERATED by scripts/update-voice-docs.js.',
    '// Do not edit this file manually.',
    '',
  ];

  exports.forEach(({ exportName, map }) => {
    lines.push(`export const ${exportName}: Record<string, any> = {`);

    const keys = Object.keys(map || {}).sort((a, b) =>
      a.localeCompare(b, undefined, { sensitivity: 'base' })
    );

    for (const key of keys) {
      const value = map[key];
      const formattedValue = formatObjectLiteral(value, '    ');
      lines.push(`  [${JSON.stringify(key)}]: ${formattedValue},`);
    }

    lines.push('};', '');
  });

  fs.writeFileSync(filePath, `${lines.join('\n')}\n`, 'utf8');
  console.log(`[write] ${path.relative(rootDir, filePath)}`);
}

function fetchJson(url, { method = 'GET', headers = {}, body } = {}) {
  const requestUrl = typeof url === 'string' ? new URL(url) : url;

  return new Promise((resolve, reject) => {
    const options = {
      method,
      hostname: requestUrl.hostname,
      path: `${requestUrl.pathname}${requestUrl.search}`,
      headers,
    };

    if (proxyAgent) {
      options.agent = proxyAgent;
    }

    const req = https.request(options, (res) => {
      const chunks = [];

      res.on('data', (chunk) => chunks.push(chunk));
      res.on('end', () => {
        const buffer = Buffer.concat(chunks);
        const text = buffer.toString('utf8');

        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
          if (!text) {
            resolve(null);
            return;
          }

          try {
            resolve(JSON.parse(text));
          } catch (error) {
            reject(
              new Error(
                `Failed to parse JSON from ${requestUrl.toString()}: ${error.message}`
              )
            );
          }
        } else {
          reject(
            new Error(
              `HTTP ${res.statusCode} ${res.statusMessage || ''} when calling ${requestUrl.toString()}: ${text}`
            )
          );
        }
      });
    });

    req.on('error', reject);

    if (body) {
      req.write(body);
    }

    req.end();
  });
}

function logSkip(service, reason) {
  console.warn(`[skip] ${service}: ${reason}`);
}

function pickEnv(...keys) {
  for (const key of keys) {
    if (process.env[key]) {
      return process.env[key];
    }
  }

  return undefined;
}

async function updateAzureVoices() {
  const key = pickEnv('AZURE_SPEECH_KEY', 'MICROSOFT_TOKEN');
  const region = pickEnv('AZURE_SPEECH_REGION', 'MICROSOFT_REGION');

  if (!key || !region) {
    logSkip(
      'azure',
      'set AZURE_SPEECH_KEY/AZURE_SPEECH_REGION or MICROSOFT_TOKEN/MICROSOFT_REGION to refresh the catalogue'
    );
    return;
  }

  const url = `https://${region}.tts.speech.microsoft.com/cognitiveservices/voices/list`;
  const headers = {
    'Ocp-Apim-Subscription-Key': key,
  };

  const data = await fetchJson(url, { headers });

  if (!Array.isArray(data)) {
    throw new Error('Unexpected Azure voice list response');
  }

  const voiceMap = {};

  for (const voice of data) {
    const name = ((voice.ShortName || voice.Name) || '').trim();

    if (!name) {
      continue;
    }

    voiceMap[name.toLowerCase()] = {
      voice: {
        name,
      },
    };
  }

  writeFormatterVoiceModule('microsoftAzureVoices.ts', [
    {
      exportName: 'MICROSOFT_AZURE_TTS_VOICES',
      map: voiceMap,
    },
  ]);
}

async function updateGoogleVoices() {
  const key = process.env.GOOGLE_TTS_API_KEY;

  if (!key) {
    logSkip('google', 'set GOOGLE_TTS_API_KEY to refresh the catalogue');
    return;
  }

  const url = new URL('https://texttospeech.googleapis.com/v1/voices');
  url.searchParams.set('key', key);

  const data = await fetchJson(url);
  const voices = data && Array.isArray(data.voices) ? data.voices : [];

  if (!voices.length) {
    logSkip('google', 'no voices returned from API');
    return;
  }

  const voiceMap = {};

  for (const voice of voices) {
    const name = (voice.name || '').trim();

    if (!name) {
      continue;
    }

    voiceMap[name.toLowerCase()] = {
      voice: {
        name,
      },
    };
  }

  writeFormatterVoiceModule('googleCloudVoices.ts', [
    {
      exportName: 'GOOGLE_CLOUD_TTS_VOICES',
      map: voiceMap,
    },
  ]);
}

async function updateWatsonVoices() {
  const urlText = process.env.WATSON_TTS_URL;
  const apiKey = process.env.WATSON_TTS_API_KEY;

  if (!urlText || !apiKey) {
    logSkip('watson', 'set WATSON_TTS_URL and WATSON_TTS_API_KEY to refresh the catalogue');
    return;
  }

  const apiUrl = new URL(urlText.endsWith('/') ? `${urlText}v1/voices` : `${urlText}/v1/voices`);
  const headers = {
    Authorization: `Basic ${Buffer.from(`apikey:${apiKey}`).toString('base64')}`,
  };

  const data = await fetchJson(apiUrl, { headers });
  const voices = data && Array.isArray(data.voices) ? data.voices : [];

  if (!voices.length) {
    logSkip('watson', 'no voices returned from API');
    return;
  }

  const voiceMap = {};

  for (const voice of voices) {
    const name = (voice.name || '').trim();

    if (!name) {
      continue;
    }

    voiceMap[name.toLowerCase()] = {
      voice: {
        name,
      },
    };
  }

  writeFormatterVoiceModule('ibmWatsonVoices.ts', [
    {
      exportName: 'IBM_WATSON_TTS_VOICES',
      map: voiceMap,
    },
  ]);
}

function fetchAwsJson({ service, region, path, method = 'GET', headers = {}, body, credentials }) {
  const host = `${service}.${region}.amazonaws.com`;
  const request = {
    host,
    path,
    method,
    service,
    region,
    headers: { ...headers },
  };

  if (body) {
    request.body = body;
    if (!request.headers['Content-Type']) {
      request.headers['Content-Type'] = 'application/json';
    }
  }

  aws4.sign(request, credentials);

  return new Promise((resolve, reject) => {
    const req = https.request(
      {
        method: request.method,
        hostname: request.host,
        path: request.path,
        headers: request.headers,
        agent: proxyAgent || undefined,
      },
      (res) => {
        const chunks = [];

        res.on('data', (chunk) => chunks.push(chunk));
        res.on('end', () => {
          const buffer = Buffer.concat(chunks);
          const text = buffer.toString('utf8');

          if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
            if (!text) {
              resolve(null);
              return;
            }

            try {
              resolve(JSON.parse(text));
            } catch (error) {
              reject(
                new Error(
                  `Failed to parse JSON from https://${host}${path}: ${error.message}`
                )
              );
            }
          } else {
            reject(
              new Error(
                `HTTP ${res.statusCode} ${res.statusMessage || ''} when calling https://${host}${path}: ${text}`
              )
            );
          }
        });
      }
    );

    req.on('error', reject);

    if (body) {
      req.write(body);
    }

    req.end();
  });
}

async function updatePollyVoices() {
  const accessKeyId = pickEnv('AWS_ACCESS_KEY_ID', 'POLLY_AWS_KEY_ID');
  const secretAccessKey = pickEnv('AWS_SECRET_ACCESS_KEY', 'POLLY_AWS_ACCESS_KEY');
  const region = pickEnv('AWS_REGION', 'AWS_DEFAULT_REGION', 'POLLY_REGION');

  if (!accessKeyId || !secretAccessKey || !region) {
    logSkip(
      'amazon-polly',
      'set AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY/AWS_REGION (or AWS_DEFAULT_REGION) or the POLLY_* equivalents to refresh the catalogue'
    );
    return;
  }

  const credentials = {
    accessKeyId,
    secretAccessKey,
  };

  if (process.env.AWS_SESSION_TOKEN) {
    credentials.sessionToken = process.env.AWS_SESSION_TOKEN;
  }

  const voices = [];
  let nextToken = null;

  do {
    const params = new URLSearchParams({ IncludeAdditionalLanguageCodes: 'true' });

    if (nextToken) {
      params.set('NextToken', nextToken);
    }

    const query = params.toString();
    const path = query ? `/v1/voices?${query}` : '/v1/voices';

    const data = await fetchAwsJson({
      service: 'polly',
      region,
      path,
      credentials,
    });

    const chunk = data && Array.isArray(data.Voices) ? data.Voices : [];

    voices.push(...chunk);
    nextToken = data && data.NextToken ? data.NextToken : null;
  } while (nextToken);

  if (!voices.length) {
    logSkip('amazon-polly', 'no voices returned from API');
    return;
  }

  const allVoices = {};
  const standardVoices = {};
  const neuralVoices = {};
  const generativeVoices = {};

  for (const voice of voices) {
    const id = (voice.Id || '').trim();

    if (!id) {
      continue;
    }

    const key = id.toLowerCase();
    const entry = {
      voice: {
        name: id,
      },
    };

    allVoices[key] = entry;

    const engines = Array.isArray(voice.SupportedEngines)
      ? voice.SupportedEngines.map((engine) => String(engine || '').toLowerCase())
      : [];

    if (engines.includes('standard')) {
      standardVoices[key] = entry;
    }

    if (engines.includes('neural')) {
      neuralVoices[key] = entry;
    }

    if (engines.includes('generative')) {
      generativeVoices[key] = entry;
    }
  }

  writeFormatterVoiceModule('amazonPollyVoices.ts', [
    {
      exportName: 'AMAZON_POLLY_ALL_VOICES',
      map: allVoices,
    },
    {
      exportName: 'AMAZON_POLLY_STANDARD_VOICES',
      map: standardVoices,
    },
    {
      exportName: 'AMAZON_POLLY_NEURAL_VOICES',
      map: neuralVoices,
    },
    {
      exportName: 'AMAZON_POLLY_GENERATIVE_VOICES',
      map: generativeVoices,
    },
  ]);
}

(async () => {
  try {
    await Promise.all([
      updateAzureVoices(),
      updateGoogleVoices(),
      updatePollyVoices(),
      updateWatsonVoices(),
    ]);
  } catch (error) {
    console.error(error.message || error);
    process.exitCode = 1;
  }
})();
